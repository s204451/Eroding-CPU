for (x from 0 to 19) {
    for (y from 0 to 19) {
        // Processing border pixel
        if (x ==0) { out_image (x,y) =0; continue ; }
        if (y ==0) { out_image (x,y) =0; continue ; }
        if (x ==19) { out_image (x,y)=0; continue ; }
        if (y ==19) { out_image (x,y)=0; continue ; }
        // Processing inner pixel
        if ( in_image (x,y) ==0) {
            // Black pixel
            out_image (x,y) =0;
        } else {
            // White pixel , checking neighboring pixels
            if ( in_image (x -1,y) ==0 or
                in_image (x+1,y)==0 or
                in_image (x,y -1) ==0 or
                in_image (x,y +1) ==0) {
                // Erode
                out_image (x,y) =0;
            } else {
                // Do not erode
                out_image (x,y) =255;
            }
        }
    }
}

1. LI R1 0                          // X = 0
2. JGT 46 R1 19                     // If X > 19 loop ended jump to __
    // // Linje 2: loop 2
    3. LI R2 0                      // Y = 0
    4. JGT 43 R2 19                 // If Y > 19 loop ended jump to __
        // Finding the out image and in image
        5. LI R0 20                 // R0 = 20
        6. MULT R0 R2               // R0 = 20*y
        7. ADD R0 R1                // R0 = x+20*y
        8. LI R3 R0                 // R3 = R0 = in_image address
        9. LI R5 400
        10. ADD R3 R5               // R3 = x+20*y+400 = out_image address
        11. LD R4 R0                 // Storing the value of memory(R0 (in_image) ) in R4
        // // Linje 4-11 (If statements)
        12. JEQ 19 R1 0             // If X == 0
        13. JEQ 19 R2 0             // If Y == 0
        14. JEQ 19 R1 19            // If X == 19
        15. JGT 19 R2 19            // If Y == 19
        17. JGT 19 R4 0             // If in_image(x,y) =0
        18. JR 21                   // Skip the next 2 lines if none of the above are true
            19. LI R5 0
            20. SD R3 R5             // Save 0 to memory(R3)= memory(out_image)
            21. JR 31               // continue
        // // Linje (12-19) else
        22. LI R5 1
        23. SUB R0 R5               // in_image(x-1,y)
        24. LD R4 R0                // Stores the value of memory(R0) in R4
        25. JEQ 19 R4 0             // if (in_image(x-1,y) == 0)

        26. LI R5 2
        27. ADD R0 R5               // in_image(x+1,y)
        28. LD R4 R0                // Stores the value of memory(R0) in R4
        29. JEQ 19 R4 0             // if (in_image(x+1,y) == 0)

        24. SUB R0 R0 21            // in_image(x,y-1)
        25. LD R4 R0                // Stores the value of R0 in R4
        26. JEQ 16 R4 0             // if (in_image(x,y-1) == 0)

        27. ADD R0 R0 40            // in_image(x,y+1)
        28. LD R4 R0                // Stores the value of R0 in R4
        29. JEQ 16 R4 0             // if (in_image(x,y+1) == 0)

        // // Linje 12-20 (else)
        38. LI R5 255
        39. SD R3 R5               // Save 255 to memory(R3)= memory(out_image)

    // Ending of loop where we increment
    31. ADD R2 R2 1                 // Add 1 to Y and save it in Y
    32. JR 4                        // Jumps back to beginning of loop 2
33. ADD R1 R1 1                     // Add 1 to X and save it in X
34. JR 2                            // Jumps back to beginning of loop 1
35. END                             // Finished loopss



// TASK 4 //

*********** LIST OF INSTRUCTIONS **********
// Arithmetic
Addition                    ADD R0 R1 R2
Subtraction                 SUB R0 R1 R2
Multiplication              MULT R0 R1 R2
Load immediate              LI R1 R2
Load data                   LD R1 R2
Store data                  SD R1 R2

// Jump type
Jump                        JR 12

// Jump Comparison Type
Jump if greater than        JGT 10 R1 R2
Jump if equal               JEQ 10 R1 R2

End program                 END
*******************************************

// TASK 4: //

// Nummereret med 2^3
// R0(9) R1(5) R2(5) R3(10) R4(8) R5(9)


// LI R0 R1
// R0 = R1

// LI R0 100
// R0 = 100
// 000010 (LI) 000 (R0) 001 (R1) 010101010101010101
// 000010 (LI) 000 (R0) 001 (100) 000000000001100 (100)


How is the 32-bit instruction divided:
Instruction type: Opcode(4) Instructions(28)
Depending on the opcode the instruction fields are divided as follows
    R(Register):          R(3)          R(3)        Nothing(22)
    I(Immediate):         R(3)          Immediate(25)
    J(Jump):              Nothing(3)    Nothing(3)  Target(15)
    JC(Jump Conditional): R1(3)         R2(3)       Target(15)
    S(Store):             R(3)          R(3)        Nothing(22)
