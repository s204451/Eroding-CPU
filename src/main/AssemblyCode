for (x from 0 to 19) {
    for (y from 0 to 19) {
        // Processing border pixel
        if (x ==0) { out_image (x,y) =0; continue ; }
        if (y ==0) { out_image (x,y) =0; continue ; }
        if (x ==19) { out_image (x,y)=0; continue ; }
        if (y ==19) { out_image (x,y)=0; continue ; }
        // Processing inner pixel
        if ( in_image (x,y) ==0) {
            // Black pixel
            out_image (x,y) =0;
        } else {
            // White pixel , checking neighboring pixels
            if ( in_image (x -1,y) ==0 or
                in_image (x+1,y)==0 or
                in_image (x,y -1) ==0 or
                in_image (x,y +1) ==0) {
                // Erode
                out_image (x,y) =0;
            } else {
                // Do not erode
                out_image (x,y) =255;
            }
        }
    }
}

1. LI R1 0                          // X = 0
2. JGT 35 R1 19                     // If X > 19 loop ended jump to __
    // // Linje 2: loop 2
    3. LI R2 0                      // Y = 0
    4. JGT 33 R2 19                 // If Y > 19 loop ended jump to __
        // Finding the out image and in image
        5. MULT R0 20 R2            // 20*y
        6. ADD R0 R0 R1             // R0 = x+20*y
        7. LI R3 R0                 // R3 = R0 = in_image address
        8. ADD R3 R3 400               // R3 = x+20*y+400 = out_image address
        9. LD R4 R0                 // Storing the value of memory(R0 (in_image) ) in R4
        // // Linje 4-11 (If statements)
        10. JEQ 16 R1 0             // If X == 0 jump to
        11. JEQ 16 R2 0             // If Y == 0 jump to next
        12. JEQ 16 R1 19            // If X == 19
        13. JGT 16 R2 19            // If Y == 19
        14. JGT 16 R4 0             // If in_image(x,y) =0
        15. JR 18                   // Skip the next 2 lines if none of the above are true
            16. SD 0 R3             // Save 0 to memory(R3)= memory(out_image)
            17. JR 31               // continue
        // // Linje (12-19) else
        18. SUB R0 R0 1             // in_image(x-1,y)
        19. LD R4 R0                // Stores the value of R0 in R4
        20. JEQ 16 R4 0             // if (in_image(x-1,y) == 0)

        21. ADD R0 R0 2             // in_image(x+1,y)
        22. LD R4 R0                // Stores the value of R0 in R4
        23. JEQ 16 R4 0             // if (in_image(x+1,y) == 0)

        24. SUB R0 R0 21            // in_image(x,y-1)
        25. LD R4 R0                // Stores the value of R0 in R4
        26. JEQ 16 R4 0             // if (in_image(x,y-1) == 0)

        27. ADD R0 R0 40            // in_image(x,y+1)
        28. LD R4 R0                // Stores the value of R0 in R4
        29. JEQ 16 R4 0             // if (in_image(x,y+1) == 0)

        // // Linje 12-20 (else)
        30. SD 255 R3               // Save 255 to memory(R3)= memory(out_image)

    // Ending of loop where we increment
    31. ADD R2 R2 1                 // Add 1 to Y and save it in Y
    32. JR 4                        // Jumps back to beginning of loop 2
33. ADD R1 R1 1                     // Add 1 to X and save it in X
34. JR 2                            // Jumps back to beginning of loop 1
35. END                             // Finished loopss



// TASK 4 //

*********** LIST OF INSTRUCTIONS **********
// Arithmetic
Addition                    ADD R0 R1 R2
Subtraction                 SUB R0 R1 R2
Multiplication              MULT R0 R1 R2
Load immediate              LI R1 R2
Load data                   LD R1 R2
Store data                  SD R1 R2

// Jump type
Jump                        JR 12

// Jump Comparison Type
Jump if greater than        JGT 10 R1 R2
Jump if equal               JEQ 10 R1 R2

End program                 END
*******************************************


// Nummereret med 2^3
// R0(9) R1(5) R2(5) R3(10) R4(8)

// LI R0 R1
// R0 = R1

// LI R0 100
// R0 = 100
// 000010 (LI) 000 (R0) 001 (R1) 010101010101010101
// 000010 (LI) 000 (R0) 001 (100) 000000000001100 (100)

R(Register Type): Opcode(4) RorV(1) R(3) Arithmetic(18)
I(Immediate Type): Opcode(4) ROrImmediate(1) R(3) Immediate(18)
J(Jump Type): Opcode(4) Target(28)
J2(Jump Comparison Type 2): Opcode(4) R1(3) R2(3) Target(22)

// TODO: spørge hjælpelærerene ROrImmediate for at skelne mellem register/værdi